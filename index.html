<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Scenery: A Scene Graph for Modern Browsers</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1>Scenery</h1>
          <h3 class="subtitle">A Scene Graph for Modern Browsers</h3>
          <p>
            Jonathan Olson<br>
            <small>
              <a href="http://phet.colorado.edu">PhET Interactive Simulations</a>
              <span style="opacity: 0.5;">|</span> University of Colorado Boulder
            </small>
          </p>
        </section>
        
        <section>
          <section>
            <h2>PhET Simulations</h2>
            <p>128 educational simulations in Java / Flash</p>
            <a href="http://phet.colorado.edu/en/simulation/plate-tectonics"><img src="http://phet.colorado.edu/sims/plate-tectonics/plate-tectonics-screenshot.png" alt="Plate Tectonics"/></a>
            <a href="http://phet.colorado.edu/en/simulation/projectile-motion"><img src="http://phet.colorado.edu/sims/projectile-motion/projectile-motion-screenshot.png" alt="Projectile Motion"/></a>
            <a href="http://phet.colorado.edu/en/simulation/circuit-construction-kit-dc"><img src="http://phet.colorado.edu/sims/circuit-construction-kit/circuit-construction-kit-dc-screenshot.png" alt="Circuit Construction Kit"/></a>
            <a href="http://phet.colorado.edu/en/simulation/build-an-atom"><img src="http://phet.colorado.edu/sims/build-an-atom/build-an-atom-screenshot.png" alt="Build an Atom"/></a>
            <a href="http://phet.colorado.edu/en/simulation/beers-law-lab"><img src="http://phet.colorado.edu/sims/beers-law-lab/beers-law-lab-screenshot.png" alt="Beer's Law Lab"/></a>
            <a href="http://phet.colorado.edu/en/simulation/fractions-intro"><img src="http://phet.colorado.edu/sims/fractions/fractions-intro-screenshot.png" alt="Fractions Intro"/></a>
          </section>
          <section>
            <ul>
              <li><a href="http://phet.colorado.edu">http://phet.colorado.edu</a></li>
              <li>Previously seen in <a href="http://spot.colorado.edu/~reids/talks/phet-html5-slides-reid-oct-2012.pdf">Sam Reid's talk</a></li>
              <li>Run over 110 million times, translated to 74 languages</li>
              <li><strong>Porting to HTML5 to be available on more devices</strong></li>
            </ul>
          </section>
          <section>
            <h3>Reasons for Scenery</h3>
            <ul>
              <li><strong>Performance</strong> and <strong>consistency</strong> between platforms<br>(iOS, Android, Windows RT, Desktop browsers)</li>
              <li>Concise and clear <strong>syntax</strong></li>
              <!-- <li>Match conventions from well-designed 2D scene graphs like <a href="http://www.piccolo2d.org/">Piccolo2D</a></li> -->
              <li><strong>Features</strong></li>
            </ul>
          </section>
          <section>
            <h3>Features we want</h3>
            <ul>
              <li>Bounds tracking</li>
              <li>Input event system (hit regions, multi-touch support, cursor support)</li>
              <li>Clipping, Masking, Opacity, Gradients, Patterns, Visibility</li>
              <li>Constructive Solid Geometry, Shape transformations</li>
              <li>Integration with arbitrary content, like 3D with <a href="https://github.com/mrdoob/three.js/">three.js</a></li>
              <li>DAG (directed acyclic graph), not just a tree</li>
              <li>Debugging utilities</li>
              <li>Accessibility</li>
            </ul>
          </section>
          <section>
            <h3>Other scene graphs</h3>
            <ul>
              <li><strong>Fabric</strong>: lacks full-featured event handling</li>
              <li><strong>Kinetic</strong>: good API with layers. hit regions need all same-origin content (issues when running locally)</li>
              <li><strong>Paper</strong>: less performance</li>
              <li><strong>CAAT</strong>: less popular, dirty rectangle issues</li>
              <li><strong>Easel</strong>: initially chosen before Scenery</li>
            </ul>
            <p style="margin-top: 15px;">
              Prototypes indicate that custom Canvas and SVG code and barebones scene graphs
              can get <a href="http://phetsims.github.io/scenery/tests/easel-performance/easel-tests.html">better performance</a>
            </p>
          </section>
        </section>
        
        <section>
          <section>
            <h2>A Tour of Scenery</h2>
            <div id="hello-world-scene" class="scene" style="width: 400px; height: 100px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
// Create a scene graph over a positioned block-level element
var scene = new scenery.Scene( $( '#hello-world-scene' ) );
 
// Add our text
scene.addChild( new scenery.Text( 'Hello World', {
  centerX: 200, // the center of our text's bounds is at x = 200
  centerY: 50, // the center of our text's bounds is at y = 50
  font: '40px sans-serif', fill: '#eee'
} ) );
 
// Paint any changes (in this case, our text).
scene.updateScene();
            </code></pre>
          </section>
          <section>
            <h3>Shapes</h3>
            <div id="shapes-scene" class="scene" style="width: 315px; height: 100px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
// simple shapes can be accelerated
scene.addChild( new scenery.Rectangle( 10, 10, 100, 80, {
  fill: '#f00', stroke: '#fff', lineWidth: 2
} ) );

scene.addChild( new scenery.Path( {
  shape: kite.Shape.regularPolygon( 8, 30 ),
  fill: '#0f0', x: 150, y: 50
} ) );

scene.addChild( new scenery.Path( {
  // Canvas-like Path API. Supports SVG Shape( 'M0 90Q155 50 0 10Z' )
  shape: new kite.Shape().lineTo( 0, 90 )
                         .quadraticCurveTo( 155, 50, 0, 10 )
                         .close(),
  fill: '#00f', x: 190
} ) );
            </code></pre>
          </section>
          <section>
            <h3>Images</h3>
            <div id="images-scene" class="scene" style="width: 260px; height: 100px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
var imageUrl = 'http://phet.colorado.edu/sims/energy-skate-park/' +
               'energy-skate-park-basics-thumbnail.png';

// direct URL reference, but cannot position based on bounds
scene.addChild( new scenery.Image( imageUrl, {
  x: 100, y: -30, rotation: Math.PI / 6,
} ) );

// can also pass in HTMLImageElement or HTMLCanvasElement references
var img = document.createElement( 'img' );
img.src = imageUrl;
scene.addChild( new scenery.Image( img, { opacity: 0.1, scale: 2 } ) );
            </code></pre>
          </section>
          <section>
            <h3>DOM Elements</h3>
            <div id="dom-scene" class="scene" style="width: 400px; height: 250px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
var element = document.createElement( 'span' );
element.innerHTML =
  '&lt;label style="display: inline;"&gt;Type in me:&lt;/label&gt;' +
  '&lt;input type="text"&gt;';
scene.addChild( new scenery.DOM( element, {
  x: 120, rotation: Math.PI / 6
} ) );

// HTML, with the same styling and positioning as Text
scene.addChild( new scenery.HTMLText( '<em>Italic</em> and <b>Bold</b> ', {
  fontSize: 30, bottom: 230, centerX: 200, fill: '#9aa'
} ) );
            </code></pre>
          </section>
          <section>
            <h3>Fills</h3>
            <div id="fills-scene" class="scene" style="width: 340px; height: 120px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
first.fill = 'rgba(255,127,0,0.8)'; // full support for CSS colors

// linear gradients
secondBottom.fill = new scenery.LinearGradient( 0, 0, 100, 0 )
                               .addColorStop( 0, '#000' )
                               .addColorStop( 1, '#666' );

// radial gradients
secondTop.fill = new scenery.RadialGradient( 32, 32, 5, 64, 64, 60 )
                            .addColorStop( 0, '#0ff' )
                            .addColorStop( 1, 'rgba(0,127,255,0)' );

// patterns
var transform = dot.Matrix3.rotation2( Math.PI / 6 )
                           .timesMatrix( dot.Matrix3.scale( 0.3 ) );
third.fill = new scenery.Pattern( img ).setTransformMatrix( transform );
            </code></pre>
          </section>
          <section>
            <h3>Strokes</h3>
            <div id="strokes-scene" class="scene" style="width: 340px; height: 120px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
first.stroke = 'rgba(255,127,0,0.8)'; // full support for CSS colors

// linear gradients
secondBottom.stroke = new scenery.LinearGradient( 0, 0, 100, 0 )
                                 .addColorStop( 0, '#000' )
                                 .addColorStop( 1, '#666' );

// radial gradients
secondTop.stroke = new scenery.RadialGradient( 32, 32, 5, 64, 64, 60 )
                              .addColorStop( 0, '#0ff' )
                              .addColorStop( 1, 'rgba(0,127,255,0)' );

// patterns
var transform = dot.Matrix3.rotation2( Math.PI / 6 )
                           .timesMatrix( dot.Matrix3.scale( 0.3 ) );
third.stroke = new scenery.Pattern( img ).setTransformMatrix( transform );
            </code></pre>
          </section>
          <section>
            <h3>Stroke Styles</h3>
            <div id="line-cap-scene" class="scene" style="width: 384px; height: 96px;"></div>
            <div id="line-join-scene" class="scene" style="width: 384px; height: 96px;"></div>
            <div id="line-dash-scene" class="scene" style="width: 384px; height: 48px;"></div>
          </section>
          <section>
            <h3>Axis-aligned Bounds</h3>
            <div id="bounds-scene" class="scene" style="width: 480px; height: 300px;"></div>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
// vertical layout
path.top = 20;
fastText.top = path.bottom + 20;
accurateText.top = fastText.bottom + 20;

// horizontal layout
fastText.left = 20;              // offset from the left
path.centerX = fastText.centerX; // center the path above
accurateText.left = path.left;   // align the lower text with the path
            </code></pre>
            <aside class="notes">Possible to implement higher-level layout on top</aside>
          </section>
          <section>
            <h3>Nested Transforms</h3>
            <div style="width: 700px; margin: 0 auto !important;">
              <div id="hier-tree-scene" class="scene" style="float: left; width: 340px; height: 300px;"></div>
              <div id="hier-coord-scene" class="scene" style="float: left; margin-left: 20px !important; width: 340px; height: 300px;"></div>
            </div>
          </section>
          <section>
            <h3>Directed Acyclic Graphs</h3>
            <div style="width: 800px; margin: 0 auto !important;">
              <div id="dag-tree-scene" class="scene" style="float: left; width: 440px; height: 500px;"></div>
              <div id="dag-coord-scene" class="scene" style="float: left; margin-left: 20px !important; width: 340px; height: 300px;"></div>
            </div>
          </section>
          <section>
            <h3>Directed Acyclic Graphs</h3>
            <pre><code data-trim class="javascript" contenteditable style="font-size: 18px; margin-top: 20px;">
var arrow = new scenery.Path( {                                  // arrow
  shape: kite.Shape.regularPolygon( 3, 20 ),
  fill: '#0f0', stroke: '#000'
} );
var section = new scenery.Node( { children: [                    // section
  new scenery.Rectangle( 0, 0, 100, 100, {                       // back
    fill: 'rgba(255,255,255,0.2)', stroke: '#000', lineWidth: 6
  } ),
  new scenery.Node( { x: 30, y: 50, children: [ arrow ] } ),     // left
  new scenery.Node( { x: 70, y: 50, children: [ arrow ] } )      // right
] } );
scene.children = [                                               // scene
  new scenery.Node( { children: [ section ], x: 40, y: 40 } ),   // bottom
  new scenery.Node( { children: [ section ], x: 140, y: 180,     // middle
                      rotation: Math.PI / 2 } ),
  new scenery.Node( { children: [ section ], x: 220, y: 90,      // top
                      rotation: Math.PI / 4 } ) ];
            </code></pre>
          </section>
          <!-- <section>
            <h3>User Input</h3>
            <div id="user-input-scene" class="scene" style="width: 340px; height: 300px;"></div>
            
          </section> -->
        </section>
        
        <section>
          <section>
            <h2>Design</h2>
            <ul>
              <li>Nodes can support multiple renderers (Canvas, SVG, DOM and soon WebGL)</li>
              <li>Internally, layers allow multiple renderers in the same scene</li>
              <li>
                The application (or Scenery itself in the future) can control what renderers
                are used for what parts of the scene.
              </li>
            </ul>
          </section>
          <section>
            <h3>Renderers</h3>
            <!-- <div style="width: 700px; margin: 0 auto !important;">
              <div id="canvas-renderer-scene" class="scene" style="width: 220px; height: 120px;"></div>
              <div id="svg-renderer-scene" class="scene" style="width: 220px; height: 120px;"></div>
              <div id="dom-renderer-scene" class="scene" style="width: 220px; height: 120px;"></div>
            </div> -->
            <ul>
              <li>
                <strong>Canvas</strong>: Less stateful than SVG/DOM, ideal for many objects
                changing every frame. Performance can be slower on high resolution (Retina) devices
                when matching pixels 1:1, but in general is fast.
              </li>
              <li>
                <strong>SVG</strong>: Performance varies widely between platforms (superior performance
                on some platforms when combined with CSS transforms, slower on others). Text looks 'crisper'
                than canvas text, and SVG can be a better choice on high-resolution devices.
              </li>
              <li>
                <strong>DOM</strong>: Supports text, images and arbitrary DOM, and may be faster for some
                cases (untested).
              </li>
              <li>
                <strong>WebGL</strong>: Anticipated highest performance for sprite-like cases, but currently lacks
                mobile browser support.
              </li>
            </ul>
            <p>
              <a href="http://phetsims.github.io/scenery/tests/renderer-comparison.html" target="_blank">Visual Comparison of Renderers</a>
            </p>
          </section>
          <section>
            <h3>Layers</h3>
          </section>
          <section>
            <h3>User Input</h3>
          </section>
          <section>
            <h3>Kite</h3>
          </section>
          <section>
            <h3>Dot</h3>
          </section>
        </section>
        
        <section>
          <section>
            <h2>Challenges</h2>
          </section>
          <section>
            <h3>Text Bounds</h3>
            <ul>
              <li>
                Without accurate or guaranteed overestimated bounds,
                we can't repaint only changed regions on canvas layers.
              </li>
              <li>
                Latest Canvas spec includes bounding boxes, but is unimplemented.
              </li>
              <li>
                Using DOM / SVG for bounds can be off by unacceptable amounts
                (height sems to be only based on the font, Unicode combining characters
                wreak havoc with bounds).
              </li>
              <li>
                For now, applications can select between:
                <ul>
                  <li>Using canvas pixel inspection to determine bounds (accurate to arbitrary precision, slow)</li>
                  <li>Don't allow text in canvas layers</li>
                  <li>Repaint everything in canvas layers when it contains text</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h3>Stroked Path Bounds</h3>
            <ul>
              <li>Again for dirty region repainting, we need accurate bounds</li>
              <li>No current API, so we implemented the calculation in JavaScript</li>
            </ul>
          </section>
          <section>
            <h3>Browser Differences</h3>
            <ul>
              <li>Many <a href="http://jonathan-olson.com/canvas-diff/canvas-diff.html" target="_blank">Canvas inconsistencies</a> exist, SVG is more consistent.</li>
              <li>Scenery works around some bugs, and constrains parameters (will error instead of being inconsistent).</li>
            </ul>
          </section>
          <section>
            <h3>Memory</h3>
            <p>iOS and many canvases</p>
          </section>
          <section>
            <h3>Canvases and Events</h3>
            <p>trusted events</p>
            <p>pointer-events</p>
          </section>
          <section>
            <h3>Antialiasing</h3>
          </section>
          <section>
            <h3>SVG images for Browsers</h3>
          </section>
          <section>
            <h3>Data URL issues if time?</h3>
          </section>
        </section>
        
        <section>
          <section>
            <h2>For the Future</h2>
          </section>
          <section>
            <h3>WebGL</h3>
          </section>
          <section>
            <h3>Scratch Canvases</h3>
          </section>
          <section>
            <h3>Accessibility</h3>
          </section>
          <section>
            <h3>CSG</h3>
          </section>
          <section>
            <h3>Input handling</h3>
            <p>Higher level, zoom/pan, etc.</p>
          </section>
          <section>
            <h3>Scenery-based Simulations</h3>
          </section>
          <section>
            <h3>Conclusion</h3>
          </section>
        </section>
        
      </div>

    </div>
    
    <!-- Scenery dependencies -->
    <script src="js/jquery-2.0.0.min.js"></script>
    <script src="js/lodash.min-1.0.0-rc.3.js"></script>
    <script src="js/has.js"></script>
    
    <!-- for converting SVG to Canvas (and data URLs) -->
    <script src="js/canvg-1.2/rgbcolor.js"></script>
    <script src="js/canvg-1.2/canvg.js"></script>
    
    <script src="js/scenery.min.js"></script>
    
    <script type="text/javascript">
      $( window ).ready( function() {
        /*---------------------------------------------------------------------------*
        * Hello World
        *----------------------------------------------------------------------------*/
        
        // Create a scene graph over the block-level element. Everything inside is replaced
        var scene = new scenery.Scene( $( '#hello-world-scene' ) );
         
        // Add our text
        scene.addChild( new scenery.Text( 'Hello World', {
          centerX: 200, // the center of our text's bounds is at x = 200
          centerY: 50, // the center of our text's bounds is at y = 50
          font: '40px sans-serif', fill: '#eee'
        } ) );
         
        // Paint any changes (in this case, our text).
        scene.updateScene();
        
        /*---------------------------------------------------------------------------*
        * Shapes
        *----------------------------------------------------------------------------*/
        
        scene = new scenery.Scene( $( '#shapes-scene' ) );
        
        scene.addChild( new scenery.Rectangle( 20, 10, 100, 80, {
          fill: '#f00', stroke: '#fff', lineWidth: 2
        } ) );
        
        scene.addChild( new scenery.Path( {
          shape: kite.Shape.regularPolygon( 8, 30 ),
          fill: '#0f0', x: 170, y: 50
        } ) );
        
        scene.addChild( new scenery.Path( {
          // shape: new kite.Shape( 'M0 90Q155 50 0 10Z' ),
          shape: new kite.Shape().lineTo( 0, 90 )
                                 .quadraticCurveTo( 155, 50, 0, 10 )
                                 .close(),
          fill: '#00f', x: 220
        } ) );
        
        scene.updateScene();
        
        /*---------------------------------------------------------------------------*
        * Images
        *----------------------------------------------------------------------------*/
        
        scene = new scenery.Scene( $( '#images-scene' ), { renderer: 'svg' } ); // SVG so we don't need extra scene updates
        var imgScene = scene;
        
        var imageUrl = 'http://phet.colorado.edu/sims/energy-skate-park/energy-skate-park-basics-thumbnail.png';
        
        // direct URL reference, but cannot position based on bounds
        scene.addChild( new scenery.Image( imageUrl, {
          x: 100, y: -30, rotation: Math.PI / 6,
        } ) );
        
        // can also pass in HTMLImageElement or HTMLCanvasElement references
        var img = document.createElement( 'img' );
        img.src = imageUrl;
        scene.addChild( new scenery.Image( img, { opacity: 0.1, scale: 2 } ) );
        
        scene.updateScene();
        
        /*---------------------------------------------------------------------------*
        * DOM
        *----------------------------------------------------------------------------*/
        
        scene = new scenery.Scene( $( '#dom-scene' ) );
        
        var element = document.createElement( 'span' );
        element.innerHTML = '<label style="display: inline;">Type in me:</label><input type="text">';
        scene.addChild( new scenery.DOM( element, { x: 120, rotation: Math.PI / 6 } ) );
        
        // HTML, with the same styling and positioning as Text
        scene.addChild( new scenery.HTMLText( '<em>Italic</em> and <b>Bold</b> ', {
          fontSize: 30, bottom: 230, centerX: 200, fill: '#9aa'
        } ) );
        
        scene.updateScene();
        
        window.scene = scene;
        
        /*---------------------------------------------------------------------------*
        * Bounds
        *----------------------------------------------------------------------------*/
        
        scene = new scenery.Scene( $( '#bounds-scene' ) );
        
        var boundsColor = 'rgba(128,255,128,0.15)';
        function addBound( node, color ) {
          scene.addChild( new scenery.Path( {
            shape: kite.Shape.bounds( node.bounds ),
            fill: color ? color : boundsColor
          } ) );
        }
        var path = new scenery.Path( {
          shape: new kite.Shape( 'M -100 -100 C -50 50 50 50 0 100' ),
          stroke: '#eee',
          lineWidth: 30,
          rotation: Math.PI / 2,
          x: 150, y: 140
        } );
        var fastText = new scenery.Text( 'Fast Text Bounds', {
          // top: path.bottom + 10,
          // left: path.left,
          font: '40px sans-serif', fill: '#eee'
        } );
        var accurateText = new scenery.Text( 'Accurate Text Bounds', {
          // top: fastText.bottom + 10,
          // left: path.left,
          font: '40px sans-serif', fill: '#eee',
          boundsMethod: 'accurate', renderer: 'canvas'
        } );
        
        // vertical layout
        path.top = 20;
        fastText.top = path.bottom + 20;
        accurateText.top = fastText.bottom + 20;
        
        // horizontal layout
        fastText.left = 20;
        path.centerX = fastText.centerX;
        accurateText.left = path.left;
        
        scene.addChild( path );
        
        scene.addChild( fastText );
        
        scene.addChild( accurateText );
        
        addBound( scene, 'rgba(128,128,255,0.1)')
        addBound( path );
        addBound( fastText );
        addBound( accurateText );
        
        scene.updateScene();
        
        /*---------------------------------------------------------------------------*
        * Fills
        *----------------------------------------------------------------------------*/
        
        (function(){
          var scene = new scenery.Scene( $( '#fills-scene' ) );
          
          var first = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 10, y: 10 } );
          scene.addChild( first );
          
          var secondBottom = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 120, y: 10 } );
          scene.addChild( secondBottom );
          
          var secondTop = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 120, y: 10 } );
          scene.addChild( secondTop );
          
          var third = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 230, y: 10 } );
          scene.addChild( third );
          
          var fillScene = scene;
          var img = document.createElement( 'img' );
          img.addEventListener( 'load', function() {
            first.fill = 'rgba(255,127,0,0.8)'; // full support for CSS colors

            secondBottom.fill = new scenery.LinearGradient( 0, 0, 100, 0 )
                                           .addColorStop( 0, '#000' )
                                           .addColorStop( 1, '#666' );

            secondTop.fill = new scenery.RadialGradient( 32, 32, 5, 64, 64, 60 )
                                        .addColorStop( 0, '#0ff' )
                                        .addColorStop( 1, 'rgba(0,127,255,0)' );
            
            var transform = dot.Matrix3.rotation2( Math.PI / 6 )
                                       .timesMatrix( dot.Matrix3.scale( 0.3 ) );
            third.fill = new scenery.Pattern( img ).setTransformMatrix( transform );
            
            scene.updateScene();
          } );
          img.src = 'http://phet.colorado.edu/images/phet-logo-yellow.png';
          
          scene.updateScene();
        })();
        
        /*---------------------------------------------------------------------------*
        * Strokes
        *----------------------------------------------------------------------------*/
        
        (function(){
          // TODO: Chrome canvas lineWidth with pattern bug (looks like half size?)
          var scene = new scenery.Scene( $( '#strokes-scene' ), { renderer: 'svg' } );
          
          var first = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 10, y: 10, lineWidth: 5 } );
          scene.addChild( first );
          
          var secondBottom = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 120, y: 10, lineWidth: 5 } );
          scene.addChild( secondBottom );
          
          var secondTop = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 120, y: 10, lineWidth: 5 } );
          scene.addChild( secondTop );
          
          var third = new scenery.Rectangle( 0, 0, 100, 100, 10, 10, { x: 230, y: 10, lineWidth: 5 } );
          scene.addChild( third );
          
          var fillScene = scene;
          var img = document.createElement( 'img' );
          img.addEventListener( 'load', function() {
            first.stroke = 'rgba(255,127,0,0.8)'; // full support for CSS colors

            secondBottom.stroke = new scenery.LinearGradient( 0, 0, 100, 0 )
                                           .addColorStop( 0, '#000' )
                                           .addColorStop( 1, '#666' );

            secondTop.stroke = new scenery.RadialGradient( 32, 32, 5, 64, 64, 60 )
                                        .addColorStop( 0, '#0ff' )
                                        .addColorStop( 1, 'rgba(0,127,255,0)' );
            
            var transform = dot.Matrix3.rotation2( Math.PI / 6 )
                                       .timesMatrix( dot.Matrix3.scale( 0.3 ) );
            third.stroke = new scenery.Pattern( img ).setTransformMatrix( transform );
            
            scene.updateScene();
          } );
          img.src = 'http://phet.colorado.edu/images/phet-logo-yellow.png';
          
          scene.updateScene();
        })();
        
        /*---------------------------------------------------------------------------*
        * Stroke styles
        *----------------------------------------------------------------------------*/
        
        var strokeTextColor = '#ddd';
        var strokeMainColor = 'rgba(255,255,255,0.7)';
        var strokeLineColor = '#a50';
        (function(){
          // TODO: Chrome canvas lineWidth with pattern bug (looks like half size?)
          var scene = new scenery.Scene( $( '#line-cap-scene' ) );
          
          scene.scale( 1.5 );
          
          scene.addChild( new scenery.Text( 'butt', {
            fontSize: 14,
            centerX: 256/6,
            y: 20,
            fill: strokeTextColor
          } ) );
          scene.addChild( new scenery.Text( 'square', {
            fontSize: 14,
            centerX: 256*3/6,
            y: 20,
            fill: strokeTextColor
          } ) );
          scene.addChild( new scenery.Text( 'round', {
            fontSize: 14,
            centerX: 256*5/6,
            y: 20,
            fill: strokeTextColor
          } ) );
          
          var shape = kite.Shape.lineSegment( 0, 50, 0, 70 );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256/6,
            stroke: strokeMainColor,
            lineWidth: 30,
            lineCap: 'butt'
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*3/6,
            stroke: strokeMainColor,
            lineWidth: 30,
            lineCap: 'square'
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*5/6,
            stroke: strokeMainColor,
            lineWidth: 30,
            lineCap: 'round'
          } ) );
          // add a red highlight
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256/6,
            stroke: strokeLineColor
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*3/6,
            stroke: strokeLineColor
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*5/6,
            stroke: strokeLineColor
          } ) );
            
          scene.updateScene();
        })();
        (function(){
          var scene = new scenery.Scene( $( '#line-join-scene' ) );
          
          scene.scale( 1.5 );
          
          scene.addChild( new scenery.Text( 'miter', {
            fontSize: 14,
            centerX: 256/6,
            y: 20,
            fill: strokeTextColor
          } ) );
          scene.addChild( new scenery.Text( 'bevel', {
            fontSize: 14,
            centerX: 256*3/6,
            y: 20,
            fill: strokeTextColor
          } ) );
          scene.addChild( new scenery.Text( 'round', {
            fontSize: 14,
            centerX: 256*5/6,
            y: 20,
            fill: strokeTextColor
          } ) );
          
          var shape = new kite.Shape().moveTo( -30, 80 ).lineTo( 0, 50 ).lineTo( 30, 80 );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256/6,
            stroke: strokeMainColor,
            lineWidth: 25,
            lineJoin: 'miter'
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*3/6,
            stroke: strokeMainColor,
            lineWidth: 25,
            lineJoin: 'bevel'
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*5/6,
            stroke: strokeMainColor,
            lineWidth: 25,
            lineJoin: 'round'
          } ) );
          // add a red highlight
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256/6,
            stroke: strokeLineColor
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*3/6,
            stroke: strokeLineColor
          } ) );
          scene.addChild( new scenery.Path( {
            shape: shape,
            x: 256*5/6,
            stroke: strokeLineColor
          } ) );
          
          scene.updateScene();
        })();
        (function(){
          var scene = new scenery.Scene( $( '#line-dash-scene' ) );
          
          scene.scale( 1.5 );
          
          scene.addChild( new scenery.Path( {
            shape: kite.Shape.lineSegment( 0, 7, 256, 7 ),
            stroke: strokeLineColor
          } ) );
          scene.addChild( new scenery.Path( {
            shape: kite.Shape.lineSegment( 0, 24, 256, 24 ),
            stroke: strokeLineColor
          } ) );
          
          scene.addChild( new scenery.Path( {
            shape: kite.Shape.lineSegment( 0, 7, 256, 7 ),
            stroke: strokeMainColor,
            lineWidth: 6,
            lineDash: [ 10, 10 ]
          } ) );
          scene.addChild( new scenery.Path( {
            shape: kite.Shape.lineSegment( 0, 24, 256, 24 ),
            stroke: strokeMainColor,
            lineWidth: 6,
            lineDash: [ 20, 8, 10, 8 ]
          } ) );
          
          scene.updateScene();
        })();
        
        /*---------------------------------------------------------------------------*
        * Hierarchy
        *----------------------------------------------------------------------------*/
        
        var graphHighlight = '#ccc';
        function graphNode( name ) {
          var text = new scenery.Text( name, {
            fontSize: 35, centerX: 0, centerY: 0, fill: '#222'
          } );
          var background = new scenery.Path( {
            shape: kite.Shape.bounds( text.bounds.dilated( 10 ) ),
            stroke: '#000',
            lineWidth: 3,
            fill: graphHighlight
          } );
          var node = new scenery.Node( {
            children: [
              background,
              text
            ]
          } );
          return node;
        }
        
        function link( aNode, bNode ) {
          return new scenery.Path( {
            shape: kite.Shape.lineSegment( aNode.centerX, 0.5 * aNode.centerY + 0.5 * aNode.bottom,
                                           bNode.centerX, 0.5 * bNode.centerY + 0.5 * bNode.top ),
            lineWidth: 5,
            stroke: graphHighlight,
            lineCap: 'square'
          } );
        }
        
        (function(){
          var scene = new scenery.Scene( $( '#hier-tree-scene' ) );
          
          var scenePoint = dot( 0, 0 );
          var aPoint = dot( -70, 80 );
          var bPoint = dot( 70, 80 );
          var cPoint = dot( -140, 160 );
          var dPoint = dot( 0, 160 );
          
          var sceneNode = graphNode( 'Scene' ); sceneNode.translation = scenePoint;
          var aNode = graphNode( 'A' ); aNode.translation = aPoint;
          var bNode = graphNode( 'B' ); bNode.translation = bPoint;
          var cNode = graphNode( 'C' ); cNode.translation = cPoint;
          var dNode = graphNode( 'D' ); dNode.translation = dPoint;
          
          scene.addChild( link( sceneNode, aNode ) );
          scene.addChild( link( sceneNode, bNode ) );
          scene.addChild( link( aNode, cNode ) );
          scene.addChild( link( aNode, dNode ) );
          
          scene.addChild( sceneNode );
          scene.addChild( aNode );
          scene.addChild( bNode );
          scene.addChild( cNode );
          scene.addChild( dNode );
          
          scene.centerX = 340/2;
          scene.centerY = 300/2;
          
          scene.updateScene();
        })();
        
        (function(){
          var scene = new scenery.Scene( $( '#hier-coord-scene' ), { renderer: 'svg' } );
          
          function axes( node, name ) {
            var main = 40;
            var sub = 38;
            var width = 2;
            
            node.addChild( new scenery.Text( name, {
              fontSize: 14,
              top: 1,
              left: 2,
              fill: 'rgba(255,255,255,0.6)'
            } ) );
            
            // Y
            node.addChild( new scenery.Path( {
              shape: new kite.Shape().moveTo( 0, 0 )
                                     .lineTo( 0, sub )
                                     .lineTo( -width, sub )
                                     .lineTo( 0, main )
                                     .lineTo( width, sub )
                                     .lineTo( 0 , sub),
              stroke: 'rgba(0,255,0,0.7)',
              lineWidth: 2
            } ) );
            
            // X
            node.addChild( new scenery.Path( {
              shape: new kite.Shape().moveTo( 0, 0 )
                                     .lineTo( sub, 0 )
                                     .lineTo( sub, -width )
                                     .lineTo( main, 0 )
                                     .lineTo( sub, width )
                                     .lineTo( sub, 0 ),
              stroke: 'rgba(255,0,0,0.7)',
              lineWidth: 2
            } ) );
            
            if ( node.parents.length ) {
              var parent = node.parents[0];
              var parentPoint = node.localToParentPoint( dot.Vector2.ZERO );
              parent.insertChild( 0, new scenery.Rectangle( 0, 0, parentPoint.x, parentPoint.y, {
                stroke: '#888',
                lineDash: [ 4, 4 ]
              } ) );
            }
          }
          
          var a = new scenery.Node( {
            x: 50,
            y: 200,
            rotation: -Math.PI / 6
          } );
          scene.addChild( a );
          
          var b = new scenery.Text( 'Xyz', {
            fontSize: 70,
            centerX: 340/2,
            top: 50,
            fill: 'rgba(255,255,255,0.7)'
          } );
          scene.addChild( b );
          
          var c = new scenery.Rectangle( 0, 0, 200, 60, { x: 30, y: 30, fill: 'rgba(255,255,255,0.4)', rotation: Math.PI / 15 } );
          a.addChild( c );
          
          var d = new scenery.Text( 'Abc', {
            fontSize: 40,
            x: 90,
            top: 60,
            fill: '#000'
            // fill: 'rgba(255,200,200,0.6)'
          } );
          a.addChild( d );
          
          axes( scene, 'scene' );
          axes( a, 'A' );
          axes( b, 'B' );
          axes( c, 'C' );
          axes( d, 'D' );
          
          scene.updateScene();
        })();
        
        /*---------------------------------------------------------------------------*
        * DAG
        *----------------------------------------------------------------------------*/
        
        (function(){
          var scene = new scenery.Scene( $( '#dag-tree-scene' ) );
          
          var sceneNode = graphNode( 'Scene' );
          var topNode = graphNode( 'Top' );
          var middleNode = graphNode( 'Middle' );
          var bottomNode = graphNode( 'Bottom' );
          var sectionNode = graphNode( 'Section' );
          var backNode = graphNode( 'Back' );
          var leftNode = graphNode( 'Left' );
          var rightNode = graphNode( 'Right' );
          var arrowNode = graphNode( 'Arrow' );
          
          bottomNode.y = 100;
          middleNode.y = 100;
          topNode.y = 100;
          
          sectionNode.y = 200;
          
          backNode.y = 300;
          leftNode.y = 300;
          rightNode.y = 300;
          
          arrowNode.y = 400;
          
          bottomNode.right = middleNode.left - 20;
          topNode.left = middleNode.right + 20;
          var offset = -( topNode.right + bottomNode.left ) / 2;
          bottomNode.x += offset;
          middleNode.x += offset;
          topNode.x += offset;
          
          backNode.right = leftNode.left - 20;
          rightNode.left = leftNode.right + 20;
          offset = -( rightNode.right + backNode.left ) / 2;
          backNode.x += offset;
          leftNode.x += offset;
          rightNode.x += offset;
          
          scene.addChild( link( sceneNode, topNode ) );
          scene.addChild( link( sceneNode, middleNode ) );
          scene.addChild( link( sceneNode, bottomNode ) );
          scene.addChild( link( topNode, sectionNode ) );
          scene.addChild( link( middleNode, sectionNode ) );
          scene.addChild( link( bottomNode, sectionNode ) );
          scene.addChild( link( sectionNode, backNode ) );
          scene.addChild( link( sectionNode, leftNode ) );
          scene.addChild( link( sectionNode, rightNode ) );
          scene.addChild( link( leftNode, arrowNode ) );
          scene.addChild( link( rightNode, arrowNode ) );
          
          scene.addChild( sceneNode );
          scene.addChild( topNode );
          scene.addChild( middleNode );
          scene.addChild( bottomNode );
          scene.addChild( sectionNode );
          scene.addChild( backNode );
          scene.addChild( leftNode );
          scene.addChild( rightNode );
          scene.addChild( arrowNode );
          
          scene.centerX = 440/2;
          scene.centerY = 500/2;
          
          scene.updateScene();
        })();
        
        (function(){
          var scene = new scenery.Scene( $( '#dag-coord-scene' ), { renderer: 'svg' } );
          
          var arrow = new scenery.Path( {
            shape: kite.Shape.regularPolygon( 3, 20 ), fill: '#0f0', stroke: '#000'
          } );
          var section = new scenery.Node( { children: [
            new scenery.Rectangle( 0, 0, 100, 100, {
              fill: 'rgba(255,255,255,0.2)', stroke: '#000', lineWidth: 6
            } ),
            new scenery.Node( { x: 30, y: 50, children: [ arrow ] } ), // left
            new scenery.Node( { x: 70, y: 50, children: [ arrow ] } )  // right
          ] } );
          scene.children = [
            new scenery.Node( { children: [ section ], x: 40, y: 40 } ),
            new scenery.Node( { children: [ section ], x: 140, y: 180,
                                rotation: Math.PI / 2 } ),
            new scenery.Node( { children: [ section ], x: 220, y: 90, 
                                rotation: Math.PI / 4 } )
          ];
          
          scene.centerX = 340/2;
          scene.centerY = 300/2;
          
          scene.updateScene();
        })();
        
        /*---------------------------------------------------------------------------*
        * User Input
        *----------------------------------------------------------------------------*/
        
        // (function(){
        //   var scene = new scenery.Scene( $( '#user-input-scene' ), { renderer: 'svg' } );
        //   scene.initializeStandaloneEvents();
          
        //   var arrow = new scenery.Path( {
        //     shape: kite.Shape.regularPolygon( 3, 20 ), fill: '#0f0', stroke: '#000'
        //   } );
        //   var section = new scenery.Node( { children: [
        //     new scenery.Rectangle( 0, 0, 100, 100, {
        //       fill: 'rgba(255,255,255,0.2)', stroke: '#000', lineWidth: 6
        //     } ),
        //     new scenery.Node( { x: 30, y: 50, children: [ arrow ] } ), // left
        //     new scenery.Node( { x: 70, y: 50, children: [ arrow ] } )  // right
        //   ] } );
        //   scene.children = [
        //     new scenery.Node( { children: [ section ], x: 40, y: 40 } ),
        //     new scenery.Node( { children: [ section ], x: 140, y: 180,
        //                         rotation: Math.PI / 2 } ),
        //     new scenery.Node( { children: [ section ], x: 220, y: 90, 
        //                         rotation: Math.PI / 4 } )
        //   ];
          
        //   section.cursor = 'pointer';
        //   _.each( scene.children, function( child ) { child.addInputListener( new scenery.SimpleDragHandler() ); } );
          
        //   scene.addInputListener( { move: function( event ) { console.log( event.pointer.point.toString() ); } } );
          
        //   scene.centerX = 340/2;
        //   scene.centerY = 300/2;
          
        //   scene.updateScene();
        // })();
        
        /*---------------------------------------------------------------------------*
        * Renderers
        *----------------------------------------------------------------------------*/
        
        // (function(){
        //   var canvasScene = new scenery.Scene( $( '#canvas-renderer-scene' ), { renderer: 'canvas' } );
        //   var svgScene = new scenery.Scene( $( '#svg-renderer-scene' ), { renderer: 'svg' } );
        //   var domScene = new scenery.Scene( $( '#dom-renderer-scene' ), { renderer: 'dom' } );
          
        //   canvasScene.addChild( new scenery.Text( 'Canvas', { boundsMethod: 'fastCanvas', bottom: 120, fill: '#eee', fontSize: 24 } ) );
        //   svgScene.addChild( new scenery.Text( 'SVG', { boundsMethod: 'fastCanvas', bottom: 120, fill: '#eee', fontSize: 24 } ) );
        //   domScene.addChild( new scenery.Text( 'DOM', { boundsMethod: 'fastCanvas', bottom: 120, fill: '#eee', fontSize: 24 } ) );
          
        //   var logo = document.createElement( 'img' );
        //   logo.addEventListener( 'load', function() {
        //     var node = new scenery.Image( logo, {
        //       scale: 0.5,
        //       rotation: Math.PI / 6,
        //       x: 130,
        //       y: 20
        //     } );
        //     canvasScene.addChild( node );
        //     canvasScene.updateScene();
        //     svgScene.addChild( node );
        //     svgScene.updateScene();
        //     domScene.addChild( node );
        //     domScene.updateScene();
        //   } );
        //   logo.src = 'http://phet.colorado.edu/images/phet-logo-yellow.png';
        // })();
        
      } );
    </script>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        keyboard: true,
        overview: true,
        center: true,
        rollingLinks: false,

        // theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        theme: 'scenery', // available themes are in /css/theme
        transition: 'default', // default/cube/page/concave/zoom/linear/fade/none
        transitionSpeed: 'fast', // or default/slow

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          // { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          // { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          // { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
